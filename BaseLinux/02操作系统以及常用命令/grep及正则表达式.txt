grep,egrep,fgrep

grep:根据模式搜索文本，并且将符合模式的文本行显示出来
Pattern：文本字符和正则表达式的元字符组合而成匹配条件

grep [option] PATTERN [FILE,...]
      -i: 表示查找的时候忽略大小写
      --color : 被模式匹配的字符串用颜色显示
      -v: 显示没有被模式匹配的行
      -o: 只显示被匹配到的字符串，每个字符串是一行
      -E: 使用扩展正则表达式
      -A: 通常后面跟一个数字，表示不但显示匹配到的那一行，而且还会匹配后面的对应数字的行，例如：grep -A 2 '^core id' /proc/cpuinfo
      -B: 通常后面跟一个数字，表示不但显示匹配到的那一行，而且还会匹配前面的对应数字的行，例如：grep -B 2 '^core id' /proc/cpuinfo
      -C: 通常后面跟一个数字，表示不但显示匹配到的那一行，而且还会匹配前面和后面的对应数字的行，例如：grep -C 2 '^core id' /proc/cpuinfo
      
正则表达式：REGular EXPression，REGEXP

正则表达式分为：
   Basic REGEXP :基本正则表达式
   Extended REGEXP : 扩展正则表达式

------基本正则表达式------

元字符：
.:匹配任意单个字符
[]:匹配指定范围内的任意单个字符
[^]:匹配指定范围外的任意单个字符
   字符集合：[:digit:],[:lower:],[:upper:],[:punct:],[:alpha:],[:space:],[:alnum:]   真正引用的时候需要放入[]内，例如[[:digit:]] 表示匹配单个数字
            数字       小写字母   大写字母     标点符号    所有字母   空白字符    字母+数字   

匹配次数：（贪婪模式）
*:匹配其前面的字符任意次
   

   所以：.* 组合就是：匹配任意长度的任意字符

\?:匹配其前面的字符1次或0次
   
\{m,n\}:匹配其前面的字符至少m次，至多n次  例如：grep 'a.\{1,3\}b' /etc/passwd

位置锚定：
^:锚定行首，此字符后面的任意内容必须出现在行首
$:锚定行尾，此字符后面的任意内容必须出现在行尾
   所以：^$:表示空白行

\<或者\b:锚定词首，表示其后面的任意字符必须作为单词首部出现
\>或者\b:锚定词尾，表示其前面的任意字符必须作为单词尾部出现

分组：
\(\):
   例如：\(ab\)* 表示ab可以出现任意次，把ab看做一个整天
   后向引用：
      \1:第一个左括号以及与之对应的右括号所包含的所有内容
      \2:依次类推..
      \3
      ...
   例如：grep '\(l..e\).*\1r$' test.txt
   
练习题：
1、分析/etc/inittab文件中如下文本中前两行的特征（每一行中出现的数字必须相同），请写出可以精确找到类似两行的模式
l1:1:wait:/etc/rc.d/rc 1
l2:2:wait:/etc/rc.d/rc 2

# grep '^l\([0-9]\):\1.*\1$' /etc/inittab
   


------扩展正则表达式------
grep -E 就相当于 egrep ，所以在使用egrep 的时候就相当于使用扩展正则表达式，就不要再写-E参数了

字符匹配：
.: (同上)
[]:(同上)
[^]:(同上)

次数匹配：
*:(同上)
?:（与基本相同，不需要'\'）
+: 匹配其前面的字符至少1次   例如找出test.txt文件中以至少一个空白字符开头的行 grep -E '[[:space:]]+' test.txt
{m,n}:(同上不需要加'\')

位置锚定：（同上）
^:
%:
\>:
\<:

分组：
():(同上不需要反斜线)
   \1,\2,\3,...

或者
|:or的意思
   例如: grep -E 'C|cat' test.txt 表示匹配:C或者cat
        grep -E '(C|c)at' test.txt 表示匹配:Cat或者cat


注意：\.：就表示'.'字符本身


------快速搜索------
fgrep：fast grep 它不支持正则表达式,给的任何字符串都当做字符串本身来搜索



小提示：http://regexper.com/  可视化正则，共学习调试





      
      